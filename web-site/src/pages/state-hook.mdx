---
title: StateHook
path: /state-hook/
---

import { MdxLayout } from "../layouts/mdx-layout"
import { InfoPanel } from "../components/panel"
export default MdxLayout

## App State Hooks

App-State-Hoo ks (or just state hooks for short) are functions used to:

- select values from the app state and provide them to a `React.FunctionComponent`
- performe some basic transformations and calculations using `Selector Functions`

## Basic Usage

```code lines=7,10,11
const store = createStore({

  state: {
    user: { name: 'John Doe', age: 32 },
    todos: []
});

const useAppState = createStateHook(AppStoreProvider);

const Hello = () => {
  const name = useAppState(state => state.user.name)
  const todos = useAppState(state => state.todos)
}
```

- First, we create a state-hook named `useAppState` using the `createStateHook` factory function.
- This `useAppState` hook than can be used in all react components to pick properties from the state using a `selector function`, for example `state => state.user.name`. More about _selector functions_
  in the section Selector Function.

## Scoped State Hook

To simplify and organise the access to various sub-states you may utilize a _scoped app state hook_.

The `createStateHook` function takes a second parameter, a `scope function`, that narrows the state to the selected object.

```code lines=1,4
const useUserState = createStateHook(AppStoreProvider, state => state.user);

const Hello = () => {
  const name = useUserState(state => state.name)
}
```

In this example, the scope is narrowed to the user object of our app state.

## Selector Function

Selector functions are used to select "portions" of your application state and - if needed - apply some basic transformations or computations.

Depending on your needs you can choose between various selector function types:

- State selector
- Sub-State selector
- Property selector
- Transforming selector
- Computing selector
- Transforming + computing selectors

### State Selector

The state selector function (identity selector) gives you access to the whole state object.

```
const appState = useAppState(state => state)
```

Warning: use state selector it wisley. The component will be re-rendered if
the state changes - no matter what properties you are actually need.

### Sub-State Selector

Sometime it is handy to select an object from the application state if you plan to consume all of it's properties in your component.

```
const user = useAppState(state => state.user)
// or
const { name, age } = useAppState(state => state.user)
```

<InfoPanel>
  <p style={{margin:0}}>
  If you use state or a sub-state selector, your component will render every time the state changes, 
  regardless if your component "consumes" all the properties of the selected object.
  </p>

<p>Consider to use <b>scoped state hook</b> and <b>property selector</b> instead:</p>

```code variant=ok title="Better"
const useUserState = createStateHook(AppStoreProvider, state => state.user)
...
const name  = useUserState(userState => userState.name);
const age  = useUserState(userState => userState.age);
```

</InfoPanel>

### Property Selector

Property selector select a single property (e.g the `name` property) from the app state. Property selectors are very
fine grain and therefore efficient selectors.

```
const name = useAppState(state => state.name)
```

### Transforming Selector

Sometime your want to transform the app-state or combine various app-state properties into a single object. You can do so with a simple
_transforming selector function_, which is a fancy name for a simple function that takes the app-state and returns the desired object.

```
const compState = useAppState(state => ({
    userName: state.user.name
    todos: state.todos
  })
)

```

### Computing Selector

Similar to Transforming Selectors, you can do basic computations as well:

```
const todosCount = useAppState(state => state.todos.length)
const todosDone = useAppState(state => state.todos.filter( todo => todo.done ))
const todosOpen = useAppState(state => state.todos.filter( todo => !todo.done ))
```

or with a scoped app state hook:

```
const useTodos = createStateHook(AppStoreProvider, state => state.todos);
...
const todosCount = useTodos(todos => todos.length)
const todosDone = useTodos(todos => todos.filter( todo => todo.done ))
const todosOpen = useTodos(todos => todos.filter( todo => !todo.done ))
```

<InfoPanel>
Computing selectors are efficient. Your component will re-render ony if the
result of the selector changes.

Take for example following snippet:

```code variant=warn title="Not efficient"
const todos = useAppState(state => state.todos)
const aLotOfWork = todos.length > 10;
```

Your component will render every time `state.todos[]` changes, even if `aLotOfWork` does not change at all.

The next snippet - using a computing selector - is efficient as react renders the component only if the value of `aLotOfWork` toggles.

```code variant=ok title="Better"
const aLotOfWork = useAppState(state => state.todos.length > 10)
```

</InfoPanel>

### Transforming + Computing Selector

Of course you can also combine computing and transforming selectors:

```
const compState = useAppState(state => ({
  userName: state.user.name,
  openTodos: state.todos.filter( todo => !todo.done ))
)}
```
